{"ast":null,"code":"/*! geolib 2.0.23 by Manuel Bieh\r\n* Library to provide geo functions like distance calculation,\r\n* conversion of decimal coordinates to sexagesimal and vice versa, etc.\r\n* WGS 84 (World Geodetic System 1984)\r\n* \r\n* @author Manuel Bieh\r\n* @url http://www.manuelbieh.com/\r\n* @version 2.0.23\r\n* @license MIT \r\n**/\n;\n\n(function (global, undefined) {\n  \"use strict\";\n\n  function Geolib() {} // Constants\n\n\n  Geolib.TO_RAD = Math.PI / 180;\n  Geolib.TO_DEG = 180 / Math.PI;\n  Geolib.PI_X2 = Math.PI * 2;\n  Geolib.PI_DIV4 = Math.PI / 4; // Setting readonly defaults\n\n  var geolib = Object.create(Geolib.prototype, {\n    version: {\n      value: \"2.0.23\"\n    },\n    radius: {\n      value: 6378137\n    },\n    minLat: {\n      value: -90\n    },\n    maxLat: {\n      value: 90\n    },\n    minLon: {\n      value: -180\n    },\n    maxLon: {\n      value: 180\n    },\n    sexagesimalPattern: {\n      value: /^([0-9]{1,3})°\\s*([0-9]{1,3}(?:\\.(?:[0-9]{1,2}))?)'\\s*(([0-9]{1,3}(\\.([0-9]{1,4}))?)\"\\s*)?([NEOSW]?)$/\n    },\n    measures: {\n      value: Object.create(Object.prototype, {\n        \"m\": {\n          value: 1\n        },\n        \"km\": {\n          value: 0.001\n        },\n        \"cm\": {\n          value: 100\n        },\n        \"mm\": {\n          value: 1000\n        },\n        \"mi\": {\n          value: 1 / 1609.344\n        },\n        \"sm\": {\n          value: 1 / 1852.216\n        },\n        \"ft\": {\n          value: 100 / 30.48\n        },\n        \"in\": {\n          value: 100 / 2.54\n        },\n        \"yd\": {\n          value: 1 / 0.9144\n        }\n      })\n    },\n    prototype: {\n      value: Geolib.prototype\n    },\n    extend: {\n      value: function value(methods, overwrite) {\n        for (var prop in methods) {\n          if (typeof geolib.prototype[prop] === 'undefined' || overwrite === true) {\n            if (typeof methods[prop] === 'function' && typeof methods[prop].bind === 'function') {\n              geolib.prototype[prop] = methods[prop].bind(geolib);\n            } else {\n              geolib.prototype[prop] = methods[prop];\n            }\n          }\n        }\n      }\n    }\n  });\n\n  if (typeof Number.prototype.toRad === 'undefined') {\n    Number.prototype.toRad = function () {\n      return this * Geolib.TO_RAD;\n    };\n  }\n\n  if (typeof Number.prototype.toDeg === 'undefined') {\n    Number.prototype.toDeg = function () {\n      return this * Geolib.TO_DEG;\n    };\n  } // Here comes the magic\n\n\n  geolib.extend({\n    decimal: {},\n    sexagesimal: {},\n    distance: null,\n    getKeys: function getKeys(point) {\n      // GeoJSON Array [longitude, latitude(, elevation)]\n      if (Object.prototype.toString.call(point) == '[object Array]') {\n        return {\n          longitude: point.length >= 1 ? 0 : undefined,\n          latitude: point.length >= 2 ? 1 : undefined,\n          elevation: point.length >= 3 ? 2 : undefined\n        };\n      }\n\n      var getKey = function getKey(possibleValues) {\n        var key;\n        possibleValues.every(function (val) {\n          // TODO: check if point is an object\n          if (typeof point != 'object') {\n            return true;\n          }\n\n          return point.hasOwnProperty(val) ? function () {\n            key = val;\n            return false;\n          }() : true;\n        });\n        return key;\n      };\n\n      var longitude = getKey(['lng', 'lon', 'longitude']);\n      var latitude = getKey(['lat', 'latitude']);\n      var elevation = getKey(['alt', 'altitude', 'elevation', 'elev']); // return undefined if not at least one valid property was found\n\n      if (typeof latitude == 'undefined' && typeof longitude == 'undefined' && typeof elevation == 'undefined') {\n        return undefined;\n      }\n\n      return {\n        latitude: latitude,\n        longitude: longitude,\n        elevation: elevation\n      };\n    },\n    // returns latitude of a given point, converted to decimal\n    // set raw to true to avoid conversion\n    getLat: function getLat(point, raw) {\n      return raw === true ? point[this.getKeys(point).latitude] : this.useDecimal(point[this.getKeys(point).latitude]);\n    },\n    // Alias for getLat\n    latitude: function latitude(point) {\n      return this.getLat.call(this, point);\n    },\n    // returns longitude of a given point, converted to decimal\n    // set raw to true to avoid conversion\n    getLon: function getLon(point, raw) {\n      return raw === true ? point[this.getKeys(point).longitude] : this.useDecimal(point[this.getKeys(point).longitude]);\n    },\n    // Alias for getLon\n    longitude: function longitude(point) {\n      return this.getLon.call(this, point);\n    },\n    getElev: function getElev(point) {\n      return point[this.getKeys(point).elevation];\n    },\n    // Alias for getElev\n    elevation: function elevation(point) {\n      return this.getElev.call(this, point);\n    },\n    coords: function coords(point, raw) {\n      var retval = {\n        latitude: raw === true ? point[this.getKeys(point).latitude] : this.useDecimal(point[this.getKeys(point).latitude]),\n        longitude: raw === true ? point[this.getKeys(point).longitude] : this.useDecimal(point[this.getKeys(point).longitude])\n      };\n      var elev = point[this.getKeys(point).elevation];\n\n      if (typeof elev !== 'undefined') {\n        retval['elevation'] = elev;\n      }\n\n      return retval;\n    },\n    // Alias for coords\n    ll: function ll(point, raw) {\n      return this.coords.call(this, point, raw);\n    },\n    // checks if a variable contains a valid latlong object\n    validate: function validate(point) {\n      var keys = this.getKeys(point);\n\n      if (typeof keys === 'undefined' || typeof keys.latitude === 'undefined' || keys.longitude === 'undefined') {\n        return false;\n      }\n\n      var lat = point[keys.latitude];\n      var lng = point[keys.longitude];\n\n      if (typeof lat === 'undefined' || !this.isDecimal(lat) && !this.isSexagesimal(lat)) {\n        return false;\n      }\n\n      if (typeof lng === 'undefined' || !this.isDecimal(lng) && !this.isSexagesimal(lng)) {\n        return false;\n      }\n\n      lat = this.useDecimal(lat);\n      lng = this.useDecimal(lng);\n\n      if (lat < this.minLat || lat > this.maxLat || lng < this.minLon || lng > this.maxLon) {\n        return false;\n      }\n\n      return true;\n    },\n\n    /**\n    * Calculates geodetic distance between two points specified by latitude/longitude using\n    * Vincenty inverse formula for ellipsoids\n    * Vincenty Inverse Solution of Geodesics on the Ellipsoid (c) Chris Veness 2002-2010\n    * (Licensed under CC BY 3.0)\n    *\n    * @param    object    Start position {latitude: 123, longitude: 123}\n    * @param    object    End position {latitude: 123, longitude: 123}\n    * @param    integer   Accuracy (in meters)\n    * @param    integer   Precision (in decimal cases)\n    * @return   integer   Distance (in meters)\n    */\n    getDistance: function getDistance(start, end, accuracy, precision) {\n      accuracy = Math.floor(accuracy) || 1;\n      precision = Math.floor(precision) || 0;\n      var s = this.coords(start);\n      var e = this.coords(end);\n      var a = 6378137,\n          b = 6356752.314245,\n          f = 1 / 298.257223563; // WGS-84 ellipsoid params\n\n      var L = (e['longitude'] - s['longitude']).toRad();\n      var cosSigma, sigma, sinAlpha, cosSqAlpha, cos2SigmaM, sinSigma;\n      var U1 = Math.atan((1 - f) * Math.tan(parseFloat(s['latitude']).toRad()));\n      var U2 = Math.atan((1 - f) * Math.tan(parseFloat(e['latitude']).toRad()));\n      var sinU1 = Math.sin(U1),\n          cosU1 = Math.cos(U1);\n      var sinU2 = Math.sin(U2),\n          cosU2 = Math.cos(U2);\n      var lambda = L,\n          lambdaP,\n          iterLimit = 100;\n\n      do {\n        var sinLambda = Math.sin(lambda),\n            cosLambda = Math.cos(lambda);\n        sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\n\n        if (sinSigma === 0) {\n          return geolib.distance = 0; // co-incident points\n        }\n\n        cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;\n        sigma = Math.atan2(sinSigma, cosSigma);\n        sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;\n        cosSqAlpha = 1 - sinAlpha * sinAlpha;\n        cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;\n\n        if (isNaN(cos2SigmaM)) {\n          cos2SigmaM = 0; // equatorial line: cosSqAlpha=0 (§6)\n        }\n\n        var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));\n        lambdaP = lambda;\n        lambda = L + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));\n      } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);\n\n      if (iterLimit === 0) {\n        return NaN; // formula failed to converge\n      }\n\n      var uSq = cosSqAlpha * (a * a - b * b) / (b * b);\n      var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));\n      var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));\n      var deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));\n      var distance = b * A * (sigma - deltaSigma);\n      distance = distance.toFixed(precision); // round to 1mm precision\n      //if (start.hasOwnProperty(elevation) && end.hasOwnProperty(elevation)) {\n\n      if (typeof this.elevation(start) !== 'undefined' && typeof this.elevation(end) !== 'undefined') {\n        var climb = Math.abs(this.elevation(start) - this.elevation(end));\n        distance = Math.sqrt(distance * distance + climb * climb);\n      }\n\n      return this.distance = Math.round(distance * Math.pow(10, precision) / accuracy) * accuracy / Math.pow(10, precision);\n      /*\n      // note: to return initial/final bearings in addition to distance, use something like:\n      var fwdAz = Math.atan2(cosU2*sinLambda,  cosU1*sinU2-sinU1*cosU2*cosLambda);\n      var revAz = Math.atan2(cosU1*sinLambda, -sinU1*cosU2+cosU1*sinU2*cosLambda);\n       return { distance: s, initialBearing: fwdAz.toDeg(), finalBearing: revAz.toDeg() };\n      */\n    },\n\n    /**\n    * Calculates the distance between two spots.\n    * This method is more simple but also far more inaccurate\n    *\n    * @param    object    Start position {latitude: 123, longitude: 123}\n    * @param    object    End position {latitude: 123, longitude: 123}\n    * @param    integer   Accuracy (in meters)\n    * @return   integer   Distance (in meters)\n    */\n    getDistanceSimple: function getDistanceSimple(start, end, accuracy) {\n      accuracy = Math.floor(accuracy) || 1;\n      var distance = Math.round(Math.acos(Math.sin(this.latitude(end).toRad()) * Math.sin(this.latitude(start).toRad()) + Math.cos(this.latitude(end).toRad()) * Math.cos(this.latitude(start).toRad()) * Math.cos(this.longitude(start).toRad() - this.longitude(end).toRad())) * this.radius);\n      return geolib.distance = Math.floor(Math.round(distance / accuracy) * accuracy);\n    },\n\n    /**\n        * Calculates the center of a collection of geo coordinates\n        *\n        * @param        array       Collection of coords [{latitude: 51.510, longitude: 7.1321}, {latitude: 49.1238, longitude: \"8° 30' W\"}, ...]\n        * @return       object      {latitude: centerLat, longitude: centerLng}\n        */\n    getCenter: function getCenter(coords) {\n      var coordsArray = coords;\n\n      if (typeof coords === 'object' && !(coords instanceof Array)) {\n        coordsArray = [];\n\n        for (var key in coords) {\n          coordsArray.push(this.coords(coords[key]));\n        }\n      }\n\n      if (!coordsArray.length) {\n        return false;\n      }\n\n      var X = 0.0;\n      var Y = 0.0;\n      var Z = 0.0;\n      var lat, lon, hyp;\n      coordsArray.forEach(function (coord) {\n        lat = this.latitude(coord).toRad();\n        lon = this.longitude(coord).toRad();\n        X += Math.cos(lat) * Math.cos(lon);\n        Y += Math.cos(lat) * Math.sin(lon);\n        Z += Math.sin(lat);\n      }, this);\n      var nb_coords = coordsArray.length;\n      X = X / nb_coords;\n      Y = Y / nb_coords;\n      Z = Z / nb_coords;\n      lon = Math.atan2(Y, X);\n      hyp = Math.sqrt(X * X + Y * Y);\n      lat = Math.atan2(Z, hyp);\n      return {\n        latitude: (lat * Geolib.TO_DEG).toFixed(6),\n        longitude: (lon * Geolib.TO_DEG).toFixed(6)\n      };\n    },\n\n    /**\n    * Gets the max and min, latitude, longitude, and elevation (if provided).\n    * @param        array       array with coords e.g. [{latitude: 51.5143, longitude: 7.4138}, {latitude: 123, longitude: 123}, ...]\n    * @return   object      {maxLat: maxLat,\n    *                     minLat: minLat\n    *                     maxLng: maxLng,\n    *                     minLng: minLng,\n    *                     maxElev: maxElev,\n    *                     minElev: minElev}\n    */\n    getBounds: function getBounds(coords) {\n      if (!coords.length) {\n        return false;\n      }\n\n      var useElevation = this.elevation(coords[0]);\n      var stats = {\n        maxLat: -Infinity,\n        minLat: Infinity,\n        maxLng: -Infinity,\n        minLng: Infinity\n      };\n\n      if (typeof useElevation != 'undefined') {\n        stats.maxElev = 0;\n        stats.minElev = Infinity;\n      }\n\n      for (var i = 0, l = coords.length; i < l; ++i) {\n        stats.maxLat = Math.max(this.latitude(coords[i]), stats.maxLat);\n        stats.minLat = Math.min(this.latitude(coords[i]), stats.minLat);\n        stats.maxLng = Math.max(this.longitude(coords[i]), stats.maxLng);\n        stats.minLng = Math.min(this.longitude(coords[i]), stats.minLng);\n\n        if (useElevation) {\n          stats.maxElev = Math.max(this.elevation(coords[i]), stats.maxElev);\n          stats.minElev = Math.min(this.elevation(coords[i]), stats.minElev);\n        }\n      }\n\n      return stats;\n    },\n\n    /**\n    * Calculates the center of the bounds of geo coordinates.\n    *\n    * On polygons like political borders (eg. states)\n    * this may gives a closer result to human expectation, than `getCenter`,\n    * because that function can be disturbed by uneven distribution of\n    * point in different sides.\n    * Imagine the US state Oklahoma: `getCenter` on that gives a southern\n    * point, because the southern border contains a lot more nodes,\n    * than the others.\n    *\n    * @param        array       Collection of coords [{latitude: 51.510, longitude: 7.1321}, {latitude: 49.1238, longitude: \"8° 30' W\"}, ...]\n    * @return       object      {latitude: centerLat, longitude: centerLng}\n    */\n    getCenterOfBounds: function getCenterOfBounds(coords) {\n      var b = this.getBounds(coords);\n      var latitude = b.minLat + (b.maxLat - b.minLat) / 2;\n      var longitude = b.minLng + (b.maxLng - b.minLng) / 2;\n      return {\n        latitude: parseFloat(latitude.toFixed(6)),\n        longitude: parseFloat(longitude.toFixed(6))\n      };\n    },\n\n    /**\n    * Computes the bounding coordinates of all points on the surface\n    * of the earth less than or equal to the specified great circle\n    * distance.\n    *\n    * @param object Point position {latitude: 123, longitude: 123}\n    * @param number Distance (in meters).\n    * @return array Collection of two points defining the SW and NE corners.\n    */\n    getBoundsOfDistance: function getBoundsOfDistance(point, distance) {\n      var latitude = this.latitude(point);\n      var longitude = this.longitude(point);\n      var radLat = latitude.toRad();\n      var radLon = longitude.toRad();\n      var radDist = distance / this.radius;\n      var minLat = radLat - radDist;\n      var maxLat = radLat + radDist;\n      var MAX_LAT_RAD = this.maxLat.toRad();\n      var MIN_LAT_RAD = this.minLat.toRad();\n      var MAX_LON_RAD = this.maxLon.toRad();\n      var MIN_LON_RAD = this.minLon.toRad();\n      var minLon;\n      var maxLon;\n\n      if (minLat > MIN_LAT_RAD && maxLat < MAX_LAT_RAD) {\n        var deltaLon = Math.asin(Math.sin(radDist) / Math.cos(radLat));\n        minLon = radLon - deltaLon;\n\n        if (minLon < MIN_LON_RAD) {\n          minLon += Geolib.PI_X2;\n        }\n\n        maxLon = radLon + deltaLon;\n\n        if (maxLon > MAX_LON_RAD) {\n          maxLon -= Geolib.PI_X2;\n        }\n      } else {\n        // A pole is within the distance.\n        minLat = Math.max(minLat, MIN_LAT_RAD);\n        maxLat = Math.min(maxLat, MAX_LAT_RAD);\n        minLon = MIN_LON_RAD;\n        maxLon = MAX_LON_RAD;\n      }\n\n      return [// Southwest\n      {\n        latitude: minLat.toDeg(),\n        longitude: minLon.toDeg()\n      }, // Northeast\n      {\n        latitude: maxLat.toDeg(),\n        longitude: maxLon.toDeg()\n      }];\n    },\n\n    /**\n    * Checks whether a point is inside of a polygon or not.\n    * Note that the polygon coords must be in correct order!\n    *\n    * @param        object      coordinate to check e.g. {latitude: 51.5023, longitude: 7.3815}\n    * @param        array       array with coords e.g. [{latitude: 51.5143, longitude: 7.4138}, {latitude: 123, longitude: 123}, ...]\n    * @return       bool        true if the coordinate is inside the given polygon\n    */\n    isPointInside: function isPointInside(latlng, coords) {\n      for (var c = false, i = -1, l = coords.length, j = l - 1; ++i < l; j = i) {\n        if ((this.longitude(coords[i]) <= this.longitude(latlng) && this.longitude(latlng) < this.longitude(coords[j]) || this.longitude(coords[j]) <= this.longitude(latlng) && this.longitude(latlng) < this.longitude(coords[i])) && this.latitude(latlng) < (this.latitude(coords[j]) - this.latitude(coords[i])) * (this.longitude(latlng) - this.longitude(coords[i])) / (this.longitude(coords[j]) - this.longitude(coords[i])) + this.latitude(coords[i])) {\n          c = !c;\n        }\n      }\n\n      return c;\n    },\n\n    /**\n     * Pre calculate the polygon coords, to speed up the point inside check.\n     * Use this function before calling isPointInsideWithPreparedPolygon()\n     * @see          Algorythm from http://alienryderflex.com/polygon/\n     * @param        array       array with coords e.g. [{latitude: 51.5143, longitude: 7.4138}, {latitude: 123, longitude: 123}, ...]\n     */\n    preparePolygonForIsPointInsideOptimized: function preparePolygonForIsPointInsideOptimized(coords) {\n      for (var i = 0, j = coords.length - 1; i < coords.length; i++) {\n        if (this.longitude(coords[j]) === this.longitude(coords[i])) {\n          coords[i].constant = this.latitude(coords[i]);\n          coords[i].multiple = 0;\n        } else {\n          coords[i].constant = this.latitude(coords[i]) - this.longitude(coords[i]) * this.latitude(coords[j]) / (this.longitude(coords[j]) - this.longitude(coords[i])) + this.longitude(coords[i]) * this.latitude(coords[i]) / (this.longitude(coords[j]) - this.longitude(coords[i]));\n          coords[i].multiple = (this.latitude(coords[j]) - this.latitude(coords[i])) / (this.longitude(coords[j]) - this.longitude(coords[i]));\n        }\n\n        j = i;\n      }\n    },\n\n    /**\n     * Checks whether a point is inside of a polygon or not.\n     * \"This is useful if you have many points that need to be tested against the same (static) polygon.\"\n     * Please call the function preparePolygonForIsPointInsideOptimized() with the same coords object before using this function.\n     * Note that the polygon coords must be in correct order!\n     *\n     * @see          Algorythm from http://alienryderflex.com/polygon/\n     *\n     * @param     object      coordinate to check e.g. {latitude: 51.5023, longitude: 7.3815}\n     * @param     array       array with coords e.g. [{latitude: 51.5143, longitude: 7.4138}, {latitude: 123, longitude: 123}, ...]\n     * @return        bool        true if the coordinate is inside the given polygon\n     */\n    isPointInsideWithPreparedPolygon: function isPointInsideWithPreparedPolygon(point, coords) {\n      var flgPointInside = false,\n          y = this.longitude(point),\n          x = this.latitude(point);\n\n      for (var i = 0, j = coords.length - 1; i < coords.length; i++) {\n        if (this.longitude(coords[i]) < y && this.longitude(coords[j]) >= y || this.longitude(coords[j]) < y && this.longitude(coords[i]) >= y) {\n          flgPointInside ^= y * coords[i].multiple + coords[i].constant < x;\n        }\n\n        j = i;\n      }\n\n      return flgPointInside;\n    },\n\n    /**\n    * Shortcut for geolib.isPointInside()\n    */\n    isInside: function isInside() {\n      return this.isPointInside.apply(this, arguments);\n    },\n\n    /**\n    * Checks whether a point is inside of a circle or not.\n    *\n    * @param        object      coordinate to check (e.g. {latitude: 51.5023, longitude: 7.3815})\n    * @param        object      coordinate of the circle's center (e.g. {latitude: 51.4812, longitude: 7.4025})\n    * @param        integer     maximum radius in meters\n    * @return       bool        true if the coordinate is within the given radius\n    */\n    isPointInCircle: function isPointInCircle(latlng, center, radius) {\n      return this.getDistance(latlng, center) < radius;\n    },\n\n    /**\n    * Shortcut for geolib.isPointInCircle()\n    */\n    withinRadius: function withinRadius() {\n      return this.isPointInCircle.apply(this, arguments);\n    },\n\n    /**\n    * Gets rhumb line bearing of two points. Find out about the difference between rhumb line and\n    * great circle bearing on Wikipedia. It's quite complicated. Rhumb line should be fine in most cases:\n    *\n    * http://en.wikipedia.org/wiki/Rhumb_line#General_and_mathematical_description\n    *\n    * Function heavily based on Doug Vanderweide's great PHP version (licensed under GPL 3.0)\n    * http://www.dougv.com/2009/07/13/calculating-the-bearing-and-compass-rose-direction-between-two-latitude-longitude-coordinates-in-php/\n    *\n    * @param        object      origin coordinate (e.g. {latitude: 51.5023, longitude: 7.3815})\n    * @param        object      destination coordinate\n    * @return       integer     calculated bearing\n    */\n    getRhumbLineBearing: function getRhumbLineBearing(originLL, destLL) {\n      // difference of longitude coords\n      var diffLon = this.longitude(destLL).toRad() - this.longitude(originLL).toRad(); // difference latitude coords phi\n\n      var diffPhi = Math.log(Math.tan(this.latitude(destLL).toRad() / 2 + Geolib.PI_DIV4) / Math.tan(this.latitude(originLL).toRad() / 2 + Geolib.PI_DIV4)); // recalculate diffLon if it is greater than pi\n\n      if (Math.abs(diffLon) > Math.PI) {\n        if (diffLon > 0) {\n          diffLon = (Geolib.PI_X2 - diffLon) * -1;\n        } else {\n          diffLon = Geolib.PI_X2 + diffLon;\n        }\n      } //return the angle, normalized\n\n\n      return (Math.atan2(diffLon, diffPhi).toDeg() + 360) % 360;\n    },\n\n    /**\n    * Gets great circle bearing of two points. See description of getRhumbLineBearing for more information\n    *\n    * @param        object      origin coordinate (e.g. {latitude: 51.5023, longitude: 7.3815})\n    * @param        object      destination coordinate\n    * @return       integer     calculated bearing\n    */\n    getBearing: function getBearing(originLL, destLL) {\n      destLL['latitude'] = this.latitude(destLL);\n      destLL['longitude'] = this.longitude(destLL);\n      originLL['latitude'] = this.latitude(originLL);\n      originLL['longitude'] = this.longitude(originLL);\n      var bearing = (Math.atan2(Math.sin(destLL['longitude'].toRad() - originLL['longitude'].toRad()) * Math.cos(destLL['latitude'].toRad()), Math.cos(originLL['latitude'].toRad()) * Math.sin(destLL['latitude'].toRad()) - Math.sin(originLL['latitude'].toRad()) * Math.cos(destLL['latitude'].toRad()) * Math.cos(destLL['longitude'].toRad() - originLL['longitude'].toRad())).toDeg() + 360) % 360;\n      return bearing;\n    },\n\n    /**\n    * Gets the compass direction from an origin coordinate to a destination coordinate.\n    *\n    * @param        object      origin coordinate (e.g. {latitude: 51.5023, longitude: 7.3815})\n    * @param        object      destination coordinate\n    * @param        string      Bearing mode. Can be either circle or rhumbline\n    * @return       object      Returns an object with a rough (NESW) and an exact direction (NNE, NE, ENE, E, ESE, etc).\n    */\n    getCompassDirection: function getCompassDirection(originLL, destLL, bearingMode) {\n      var direction;\n      var bearing;\n\n      if (bearingMode == 'circle') {\n        // use great circle bearing\n        bearing = this.getBearing(originLL, destLL);\n      } else {\n        // default is rhumb line bearing\n        bearing = this.getRhumbLineBearing(originLL, destLL);\n      }\n\n      switch (Math.round(bearing / 22.5)) {\n        case 1:\n          direction = {\n            exact: \"NNE\",\n            rough: \"N\"\n          };\n          break;\n\n        case 2:\n          direction = {\n            exact: \"NE\",\n            rough: \"N\"\n          };\n          break;\n\n        case 3:\n          direction = {\n            exact: \"ENE\",\n            rough: \"E\"\n          };\n          break;\n\n        case 4:\n          direction = {\n            exact: \"E\",\n            rough: \"E\"\n          };\n          break;\n\n        case 5:\n          direction = {\n            exact: \"ESE\",\n            rough: \"E\"\n          };\n          break;\n\n        case 6:\n          direction = {\n            exact: \"SE\",\n            rough: \"E\"\n          };\n          break;\n\n        case 7:\n          direction = {\n            exact: \"SSE\",\n            rough: \"S\"\n          };\n          break;\n\n        case 8:\n          direction = {\n            exact: \"S\",\n            rough: \"S\"\n          };\n          break;\n\n        case 9:\n          direction = {\n            exact: \"SSW\",\n            rough: \"S\"\n          };\n          break;\n\n        case 10:\n          direction = {\n            exact: \"SW\",\n            rough: \"S\"\n          };\n          break;\n\n        case 11:\n          direction = {\n            exact: \"WSW\",\n            rough: \"W\"\n          };\n          break;\n\n        case 12:\n          direction = {\n            exact: \"W\",\n            rough: \"W\"\n          };\n          break;\n\n        case 13:\n          direction = {\n            exact: \"WNW\",\n            rough: \"W\"\n          };\n          break;\n\n        case 14:\n          direction = {\n            exact: \"NW\",\n            rough: \"W\"\n          };\n          break;\n\n        case 15:\n          direction = {\n            exact: \"NNW\",\n            rough: \"N\"\n          };\n          break;\n\n        default:\n          direction = {\n            exact: \"N\",\n            rough: \"N\"\n          };\n      }\n\n      direction['bearing'] = bearing;\n      return direction;\n    },\n\n    /**\n    * Shortcut for getCompassDirection\n    */\n    getDirection: function getDirection(originLL, destLL, bearingMode) {\n      return this.getCompassDirection.apply(this, arguments);\n    },\n\n    /**\n    * Sorts an array of coords by distance from a reference coordinate\n    *\n    * @param        object      reference coordinate e.g. {latitude: 51.5023, longitude: 7.3815}\n    * @param        mixed       array or object with coords [{latitude: 51.5143, longitude: 7.4138}, {latitude: 123, longitude: 123}, ...]\n    * @return       array       ordered array\n    */\n    orderByDistance: function orderByDistance(latlng, coords) {\n      var coordsArray = Object.keys(coords).map(function (idx) {\n        var distance = this.getDistance(latlng, coords[idx]);\n        var augmentedCoord = Object.create(coords[idx]);\n        augmentedCoord.distance = distance;\n        augmentedCoord.key = idx;\n        return augmentedCoord;\n      }, this);\n      return coordsArray.sort(function (a, b) {\n        return a.distance - b.distance;\n      });\n    },\n\n    /**\n    * Check if a point lies in line created by two other points\n    *\n    * @param    object    Point to check: {latitude: 123, longitude: 123}\n    * @param    object    Start of line {latitude: 123, longitude: 123}\n    * @param    object    End of line {latitude: 123, longitude: 123}\n    * @return   boolean\n    */\n    isPointInLine: function isPointInLine(point, start, end) {\n      return (this.getDistance(start, point, 1, 3) + this.getDistance(point, end, 1, 3)).toFixed(3) == this.getDistance(start, end, 1, 3);\n    },\n\n    /**\n    * Check if a point lies within a given distance from a line created by two other points\n    *\n    * @param    object    Point to check: {latitude: 123, longitude: 123}\n    * @param    object    Start of line {latitude: 123, longitude: 123}\n    * @param    object    End of line {latitude: 123, longitude: 123}\n    * @pararm   float     maximum distance from line\n    * @return   boolean\n    */\n    isPointNearLine: function isPointNearLine(point, start, end, distance) {\n      return this.getDistanceFromLine(point, start, end) < distance;\n    },\n\n    /**\n    * return the minimum distance from a point to a line\n    *\n    * @param    object    Point away from line\n    * @param    object    Start of line {latitude: 123, longitude: 123}\n    * @param    object    End of line {latitude: 123, longitude: 123}\n    * @return   float     distance from point to line\n    */\n    getDistanceFromLine: function getDistanceFromLine(point, start, end) {\n      var d1 = this.getDistance(start, point, 1, 3);\n      var d2 = this.getDistance(point, end, 1, 3);\n      var d3 = this.getDistance(start, end, 1, 3);\n      var distance = 0; // alpha is the angle between the line from start to point, and from start to end //\n\n      var alpha = Math.acos((d1 * d1 + d3 * d3 - d2 * d2) / (2 * d1 * d3)); // beta is the angle between the line from end to point and from end to start //\n\n      var beta = Math.acos((d2 * d2 + d3 * d3 - d1 * d1) / (2 * d2 * d3)); // if the angle is greater than 90 degrees, then the minimum distance is the\n      // line from the start to the point //\n\n      if (alpha > Math.PI / 2) {\n        distance = d1;\n      } // same for the beta //\n      else if (beta > Math.PI / 2) {\n          distance = d2;\n        } // otherwise the minimum distance is achieved through a line perpendular to the start-end line,\n        // which goes from the start-end line to the point //\n        else {\n            distance = Math.sin(alpha) * d1;\n          }\n\n      return distance;\n    },\n\n    /**\n    * Finds the nearest coordinate to a reference coordinate\n    *\n    * @param        object      reference coordinate e.g. {latitude: 51.5023, longitude: 7.3815}\n    * @param        mixed       array or object with coords [{latitude: 51.5143, longitude: 7.4138}, {latitude: 123, longitude: 123}, ...]\n    * @return       array       ordered array\n    */\n    findNearest: function findNearest(latlng, coords, offset, limit) {\n      offset = offset || 0;\n      limit = limit || 1;\n      var ordered = this.orderByDistance(latlng, coords);\n\n      if (limit === 1) {\n        return ordered[offset];\n      } else {\n        return ordered.splice(offset, limit);\n      }\n    },\n\n    /**\n    * Calculates the length of a given path\n    *\n    * @param        mixed       array or object with coords [{latitude: 51.5143, longitude: 7.4138}, {latitude: 123, longitude: 123}, ...]\n    * @return       integer     length of the path (in meters)\n    */\n    getPathLength: function getPathLength(coords) {\n      var dist = 0;\n      var last;\n\n      for (var i = 0, l = coords.length; i < l; ++i) {\n        if (last) {\n          //console.log(coords[i], last, this.getDistance(coords[i], last));\n          dist += this.getDistance(this.coords(coords[i]), last);\n        }\n\n        last = this.coords(coords[i]);\n      }\n\n      return dist;\n    },\n\n    /**\n    * Calculates the speed between to points within a given time span.\n    *\n    * @param        object      coords with javascript timestamp {latitude: 51.5143, longitude: 7.4138, time: 1360231200880}\n    * @param        object      coords with javascript timestamp {latitude: 51.5502, longitude: 7.4323, time: 1360245600460}\n    * @param        object      options (currently \"unit\" is the only option. Default: km(h));\n    * @return       float       speed in unit per hour\n    */\n    getSpeed: function getSpeed(start, end, options) {\n      var unit = options && options.unit || 'km';\n\n      if (unit == 'mph') {\n        unit = 'mi';\n      } else if (unit == 'kmh') {\n        unit = 'km';\n      }\n\n      var distance = geolib.getDistance(start, end);\n      var time = end.time * 1 / 1000 - start.time * 1 / 1000;\n      var mPerHr = distance / time * 3600;\n      var speed = Math.round(mPerHr * this.measures[unit] * 10000) / 10000;\n      return speed;\n    },\n\n    /**\n     * Computes the destination point given an initial point, a distance\n     * and a bearing\n     *\n     * see http://www.movable-type.co.uk/scripts/latlong.html for the original code\n     *\n     * @param        object     start coordinate (e.g. {latitude: 51.5023, longitude: 7.3815})\n     * @param        float      longitude of the inital point in degree\n     * @param        float      distance to go from the inital point in meter\n     * @param        float      bearing in degree of the direction to go, e.g. 0 = north, 180 = south\n     * @param        float      optional (in meter), defaults to mean radius of the earth\n     * @return       object     {latitude: destLat (in degree), longitude: destLng (in degree)}\n     */\n    computeDestinationPoint: function computeDestinationPoint(start, distance, bearing, radius) {\n      var lat = this.latitude(start);\n      var lng = this.longitude(start);\n      radius = typeof radius === 'undefined' ? this.radius : Number(radius);\n      var δ = Number(distance) / radius; // angular distance in radians\n\n      var θ = Number(bearing).toRad();\n      var φ1 = Number(lat).toRad();\n      var λ1 = Number(lng).toRad();\n      var φ2 = Math.asin(Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(θ));\n      var λ2 = λ1 + Math.atan2(Math.sin(θ) * Math.sin(δ) * Math.cos(φ1), Math.cos(δ) - Math.sin(φ1) * Math.sin(φ2));\n      λ2 = (λ2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180..+180°\n\n      return {\n        latitude: φ2.toDeg(),\n        longitude: λ2.toDeg()\n      };\n    },\n\n    /**\n    * Converts a distance from meters to km, mm, cm, mi, ft, in or yd\n    *\n    * @param        string      Format to be converted in\n    * @param        float       Distance in meters\n    * @param        float       Decimal places for rounding (default: 4)\n    * @return       float       Converted distance\n    */\n    convertUnit: function convertUnit(unit, distance, round) {\n      if (distance === 0) {\n        return 0;\n      } else if (typeof distance === 'undefined') {\n        if (this.distance === null) {\n          throw new Error('No distance was given');\n        } else if (this.distance === 0) {\n          return 0;\n        } else {\n          distance = this.distance;\n        }\n      }\n\n      unit = unit || 'm';\n      round = null == round ? 4 : round;\n\n      if (typeof this.measures[unit] !== 'undefined') {\n        return this.round(distance * this.measures[unit], round);\n      } else {\n        throw new Error('Unknown unit for conversion.');\n      }\n    },\n\n    /**\n    * Checks if a value is in decimal format or, if neccessary, converts to decimal\n    *\n    * @param        mixed       Value(s) to be checked/converted (array of latlng objects, latlng object, sexagesimal string, float)\n    * @return       float       Input data in decimal format\n    */\n    useDecimal: function useDecimal(value) {\n      if (Object.prototype.toString.call(value) === '[object Array]') {\n        var geolib = this;\n        value = value.map(function (val) {\n          //if(!isNaN(parseFloat(val))) {\n          if (geolib.isDecimal(val)) {\n            return geolib.useDecimal(val);\n          } else if (typeof val == 'object') {\n            if (geolib.validate(val)) {\n              return geolib.coords(val);\n            } else {\n              for (var prop in val) {\n                val[prop] = geolib.useDecimal(val[prop]);\n              }\n\n              return val;\n            }\n          } else if (geolib.isSexagesimal(val)) {\n            return geolib.sexagesimal2decimal(val);\n          } else {\n            return val;\n          }\n        });\n        return value;\n      } else if (typeof value === 'object' && this.validate(value)) {\n        return this.coords(value);\n      } else if (typeof value === 'object') {\n        for (var prop in value) {\n          value[prop] = this.useDecimal(value[prop]);\n        }\n\n        return value;\n      }\n\n      if (this.isDecimal(value)) {\n        return parseFloat(value);\n      } else if (this.isSexagesimal(value) === true) {\n        return parseFloat(this.sexagesimal2decimal(value));\n      }\n\n      throw new Error('Unknown format.');\n    },\n\n    /**\n    * Converts a decimal coordinate value to sexagesimal format\n    *\n    * @param        float       decimal\n    * @return       string      Sexagesimal value (XX° YY' ZZ\")\n    */\n    decimal2sexagesimal: function decimal2sexagesimal(dec) {\n      if (dec in this.sexagesimal) {\n        return this.sexagesimal[dec];\n      }\n\n      var tmp = dec.toString().split('.');\n      var deg = Math.abs(tmp[0]);\n      var min = ('0.' + (tmp[1] || 0)) * 60;\n      var sec = min.toString().split('.');\n      min = Math.floor(min);\n      sec = (('0.' + (sec[1] || 0)) * 60).toFixed(2);\n      this.sexagesimal[dec] = deg + '° ' + min + \"' \" + sec + '\"';\n      return this.sexagesimal[dec];\n    },\n\n    /**\n    * Converts a sexagesimal coordinate to decimal format\n    *\n    * @param        float       Sexagesimal coordinate\n    * @return       string      Decimal value (XX.XXXXXXXX)\n    */\n    sexagesimal2decimal: function sexagesimal2decimal(sexagesimal) {\n      if (sexagesimal in this.decimal) {\n        return this.decimal[sexagesimal];\n      }\n\n      var regEx = new RegExp(this.sexagesimalPattern);\n      var data = regEx.exec(sexagesimal);\n      var min = 0,\n          sec = 0;\n\n      if (data) {\n        min = parseFloat(data[2] / 60);\n        sec = parseFloat(data[4] / 3600) || 0;\n      }\n\n      var dec = (parseFloat(data[1]) + min + sec).toFixed(8); //var   dec = ((parseFloat(data[1]) + min + sec));\n      // South and West are negative decimals\n\n      dec = data[7] == 'S' || data[7] == 'W' ? parseFloat(-dec) : parseFloat(dec); //dec = (data[7] == 'S' || data[7] == 'W') ? -dec : dec;\n\n      this.decimal[sexagesimal] = dec;\n      return dec;\n    },\n\n    /**\n    * Checks if a value is in decimal format\n    *\n    * @param        string      Value to be checked\n    * @return       bool        True if in sexagesimal format\n    */\n    isDecimal: function isDecimal(value) {\n      value = value.toString().replace(/\\s*/, ''); // looks silly but works as expected\n      // checks if value is in decimal format\n\n      return !isNaN(parseFloat(value)) && parseFloat(value) == value;\n    },\n\n    /**\n    * Checks if a value is in sexagesimal format\n    *\n    * @param        string      Value to be checked\n    * @return       bool        True if in sexagesimal format\n    */\n    isSexagesimal: function isSexagesimal(value) {\n      value = value.toString().replace(/\\s*/, '');\n      return this.sexagesimalPattern.test(value);\n    },\n    round: function round(value, n) {\n      var decPlace = Math.pow(10, n);\n      return Math.round(value * decPlace) / decPlace;\n    }\n  }); // Node module\n\n  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = geolib; // react native\n\n    if (typeof global === 'object') {\n      global.geolib = geolib;\n    } // AMD module\n\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"geolib\", [], function () {\n      return geolib;\n    }); // we're in a browser\n  } else {\n    global.geolib = geolib;\n  }\n})(this);","map":{"version":3,"sources":["/Users/michaelmuniz/Desktop/client/node_modules/geolib/dist/geolib.js"],"names":["global","undefined","Geolib","TO_RAD","Math","PI","TO_DEG","PI_X2","PI_DIV4","geolib","Object","create","prototype","version","value","radius","minLat","maxLat","minLon","maxLon","sexagesimalPattern","measures","extend","methods","overwrite","prop","bind","Number","toRad","toDeg","decimal","sexagesimal","distance","getKeys","point","toString","call","longitude","length","latitude","elevation","getKey","possibleValues","key","every","val","hasOwnProperty","getLat","raw","useDecimal","getLon","getElev","coords","retval","elev","ll","validate","keys","lat","lng","isDecimal","isSexagesimal","getDistance","start","end","accuracy","precision","floor","s","e","a","b","f","L","cosSigma","sigma","sinAlpha","cosSqAlpha","cos2SigmaM","sinSigma","U1","atan","tan","parseFloat","U2","sinU1","sin","cosU1","cos","sinU2","cosU2","lambda","lambdaP","iterLimit","sinLambda","cosLambda","sqrt","atan2","isNaN","C","abs","NaN","uSq","A","B","deltaSigma","toFixed","climb","round","pow","getDistanceSimple","acos","getCenter","coordsArray","Array","push","X","Y","Z","lon","hyp","forEach","coord","nb_coords","getBounds","useElevation","stats","Infinity","maxLng","minLng","maxElev","minElev","i","l","max","min","getCenterOfBounds","getBoundsOfDistance","radLat","radLon","radDist","MAX_LAT_RAD","MIN_LAT_RAD","MAX_LON_RAD","MIN_LON_RAD","deltaLon","asin","isPointInside","latlng","c","j","preparePolygonForIsPointInsideOptimized","constant","multiple","isPointInsideWithPreparedPolygon","flgPointInside","y","x","isInside","apply","arguments","isPointInCircle","center","withinRadius","getRhumbLineBearing","originLL","destLL","diffLon","diffPhi","log","getBearing","bearing","getCompassDirection","bearingMode","direction","exact","rough","getDirection","orderByDistance","map","idx","augmentedCoord","sort","isPointInLine","isPointNearLine","getDistanceFromLine","d1","d2","d3","alpha","beta","findNearest","offset","limit","ordered","splice","getPathLength","dist","last","getSpeed","options","unit","time","mPerHr","speed","computeDestinationPoint","δ","θ","φ1","λ1","φ2","λ2","convertUnit","Error","sexagesimal2decimal","decimal2sexagesimal","dec","tmp","split","deg","sec","regEx","RegExp","data","exec","replace","test","n","decPlace","module","exports","define","amd"],"mappings":"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","sourcesContent":["/*! geolib 2.0.23 by Manuel Bieh\r\n* Library to provide geo functions like distance calculation,\r\n* conversion of decimal coordinates to sexagesimal and vice versa, etc.\r\n* WGS 84 (World Geodetic System 1984)\r\n* \r\n* @author Manuel Bieh\r\n* @url http://www.manuelbieh.com/\r\n* @version 2.0.23\r\n* @license MIT \r\n**/;(function(global, undefined) {\n\n    \"use strict\";\n\n    function Geolib() {}\n\n    // Constants\n    Geolib.TO_RAD = Math.PI / 180;\n    Geolib.TO_DEG = 180 / Math.PI;\n    Geolib.PI_X2 = Math.PI * 2;\n    Geolib.PI_DIV4 = Math.PI / 4;\n\n    // Setting readonly defaults\n    var geolib = Object.create(Geolib.prototype, {\n        version: {\n            value: \"2.0.23\"\n        },\n        radius: {\n            value: 6378137\n        },\n        minLat: {\n            value: -90\n        },\n        maxLat: {\n            value: 90\n        },\n        minLon: {\n            value: -180\n        },\n        maxLon: {\n            value: 180\n        },\n        sexagesimalPattern: {\n            value: /^([0-9]{1,3})°\\s*([0-9]{1,3}(?:\\.(?:[0-9]{1,2}))?)'\\s*(([0-9]{1,3}(\\.([0-9]{1,4}))?)\"\\s*)?([NEOSW]?)$/\n        },\n        measures: {\n            value: Object.create(Object.prototype, {\n                \"m\" : {value: 1},\n                \"km\": {value: 0.001},\n                \"cm\": {value: 100},\n                \"mm\": {value: 1000},\n                \"mi\": {value: (1 / 1609.344)},\n                \"sm\": {value: (1 / 1852.216)},\n                \"ft\": {value: (100 / 30.48)},\n                \"in\": {value: (100 / 2.54)},\n                \"yd\": {value: (1 / 0.9144)}\n            })\n        },\n        prototype: {\n            value: Geolib.prototype\n        },\n        extend: {\n            value: function(methods, overwrite) {\n                for(var prop in methods) {\n                    if(typeof geolib.prototype[prop] === 'undefined' || overwrite === true) {\n                        if(typeof methods[prop] === 'function' && typeof methods[prop].bind === 'function') {\n                            geolib.prototype[prop] = methods[prop].bind(geolib);\n                        } else {\n                            geolib.prototype[prop] = methods[prop];\n                        }\n                    }\n                }\n            }\n        }\n    });\n\n    if (typeof(Number.prototype.toRad) === 'undefined') {\n        Number.prototype.toRad = function() {\n            return this * Geolib.TO_RAD;\n        };\n    }\n\n    if (typeof(Number.prototype.toDeg) === 'undefined') {\n        Number.prototype.toDeg = function() {\n            return this * Geolib.TO_DEG;\n        };\n    }\n\n    // Here comes the magic\n    geolib.extend({\n\n        decimal: {},\n\n        sexagesimal: {},\n\n        distance: null,\n\n        getKeys: function(point) {\n\n            // GeoJSON Array [longitude, latitude(, elevation)]\n            if(Object.prototype.toString.call(point) == '[object Array]') {\n\n                return {\n                    longitude: point.length >= 1 ? 0 : undefined,\n                    latitude: point.length >= 2 ? 1 : undefined,\n                    elevation: point.length >= 3 ? 2 : undefined\n                };\n\n            }\n\n            var getKey = function(possibleValues) {\n\n                var key;\n\n                possibleValues.every(function(val) {\n                    // TODO: check if point is an object\n                    if(typeof point != 'object') {\n                        return true;\n                    }\n                    return point.hasOwnProperty(val) ? (function() { key = val; return false; }()) : true;\n                });\n\n                return key;\n\n            };\n\n            var longitude = getKey(['lng', 'lon', 'longitude']);\n            var latitude = getKey(['lat', 'latitude']);\n            var elevation = getKey(['alt', 'altitude', 'elevation', 'elev']);\n\n            // return undefined if not at least one valid property was found\n            if(typeof latitude == 'undefined' &&\n                typeof longitude == 'undefined' &&\n                typeof elevation == 'undefined') {\n                return undefined;\n            }\n\n            return {\n                latitude: latitude,\n                longitude: longitude,\n                elevation: elevation\n            };\n\n        },\n\n        // returns latitude of a given point, converted to decimal\n        // set raw to true to avoid conversion\n        getLat: function(point, raw) {\n            return raw === true ? point[this.getKeys(point).latitude] : this.useDecimal(point[this.getKeys(point).latitude]);\n        },\n\n        // Alias for getLat\n        latitude: function(point) {\n            return this.getLat.call(this, point);\n        },\n\n        // returns longitude of a given point, converted to decimal\n        // set raw to true to avoid conversion\n        getLon: function(point, raw) {\n            return raw === true ? point[this.getKeys(point).longitude] : this.useDecimal(point[this.getKeys(point).longitude]);\n        },\n\n        // Alias for getLon\n        longitude: function(point) {\n            return this.getLon.call(this, point);\n        },\n\n        getElev: function(point) {\n            return point[this.getKeys(point).elevation];\n        },\n\n        // Alias for getElev\n        elevation: function(point) {\n            return this.getElev.call(this, point);\n        },\n\n        coords: function(point, raw) {\n\n            var retval = {\n                latitude: raw === true ? point[this.getKeys(point).latitude] : this.useDecimal(point[this.getKeys(point).latitude]),\n                longitude: raw === true ? point[this.getKeys(point).longitude] : this.useDecimal(point[this.getKeys(point).longitude])\n            };\n\n            var elev = point[this.getKeys(point).elevation];\n\n            if(typeof elev !== 'undefined') {\n                retval['elevation'] = elev;\n            }\n\n            return retval;\n\n        },\n\n        // Alias for coords\n        ll: function(point, raw) {\n            return this.coords.call(this, point, raw);\n        },\n\n\n        // checks if a variable contains a valid latlong object\n        validate: function(point) {\n\n            var keys = this.getKeys(point);\n\n            if(typeof keys === 'undefined' || typeof keys.latitude === 'undefined' || keys.longitude === 'undefined') {\n                return false;\n            }\n\n            var lat = point[keys.latitude];\n            var lng = point[keys.longitude];\n\n            if(typeof lat === 'undefined' || !this.isDecimal(lat) && !this.isSexagesimal(lat)) {\n                return false;\n            }\n\n            if(typeof lng === 'undefined' || !this.isDecimal(lng) && !this.isSexagesimal(lng)) {\n                return false;\n            }\n\n            lat = this.useDecimal(lat);\n            lng = this.useDecimal(lng);\n\n            if(lat < this.minLat || lat > this.maxLat || lng < this.minLon || lng > this.maxLon) {\n                return false;\n            }\n\n            return true;\n\n        },\n\n        /**\n        * Calculates geodetic distance between two points specified by latitude/longitude using\n        * Vincenty inverse formula for ellipsoids\n        * Vincenty Inverse Solution of Geodesics on the Ellipsoid (c) Chris Veness 2002-2010\n        * (Licensed under CC BY 3.0)\n        *\n        * @param    object    Start position {latitude: 123, longitude: 123}\n        * @param    object    End position {latitude: 123, longitude: 123}\n        * @param    integer   Accuracy (in meters)\n        * @param    integer   Precision (in decimal cases)\n        * @return   integer   Distance (in meters)\n        */\n        getDistance: function(start, end, accuracy, precision) {\n\n            accuracy = Math.floor(accuracy) || 1;\n            precision = Math.floor(precision) || 0;\n\n            var s = this.coords(start);\n            var e = this.coords(end);\n\n            var a = 6378137, b = 6356752.314245,  f = 1/298.257223563;  // WGS-84 ellipsoid params\n            var L = (e['longitude']-s['longitude']).toRad();\n\n            var cosSigma, sigma, sinAlpha, cosSqAlpha, cos2SigmaM, sinSigma;\n\n            var U1 = Math.atan((1-f) * Math.tan(parseFloat(s['latitude']).toRad()));\n            var U2 = Math.atan((1-f) * Math.tan(parseFloat(e['latitude']).toRad()));\n            var sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);\n            var sinU2 = Math.sin(U2), cosU2 = Math.cos(U2);\n\n            var lambda = L, lambdaP, iterLimit = 100;\n            do {\n                var sinLambda = Math.sin(lambda), cosLambda = Math.cos(lambda);\n                sinSigma = (\n                    Math.sqrt(\n                        (\n                            cosU2 * sinLambda\n                        ) * (\n                            cosU2 * sinLambda\n                        ) + (\n                            cosU1 * sinU2 - sinU1 * cosU2 * cosLambda\n                        ) * (\n                            cosU1 * sinU2 - sinU1 * cosU2 * cosLambda\n                        )\n                    )\n                );\n                if (sinSigma === 0) {\n                    return geolib.distance = 0;  // co-incident points\n                }\n\n                cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;\n                sigma = Math.atan2(sinSigma, cosSigma);\n                sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;\n                cosSqAlpha = 1 - sinAlpha * sinAlpha;\n                cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;\n\n                if (isNaN(cos2SigmaM)) {\n                    cos2SigmaM = 0;  // equatorial line: cosSqAlpha=0 (§6)\n                }\n                var C = (\n                    f / 16 * cosSqAlpha * (\n                        4 + f * (\n                            4 - 3 * cosSqAlpha\n                        )\n                    )\n                );\n                lambdaP = lambda;\n                lambda = (\n                    L + (\n                        1 - C\n                    ) * f * sinAlpha * (\n                        sigma + C * sinSigma * (\n                            cos2SigmaM + C * cosSigma * (\n                                -1 + 2 * cos2SigmaM * cos2SigmaM\n                            )\n                        )\n                    )\n                );\n\n            } while (Math.abs(lambda-lambdaP) > 1e-12 && --iterLimit>0);\n\n            if (iterLimit === 0) {\n                return NaN;  // formula failed to converge\n            }\n\n            var uSq = (\n                cosSqAlpha * (\n                    a * a - b * b\n                ) / (\n                    b*b\n                )\n            );\n\n            var A = (\n                1 + uSq / 16384 * (\n                    4096 + uSq * (\n                        -768 + uSq * (\n                            320 - 175 * uSq\n                        )\n                    )\n                )\n            );\n\n            var B = (\n                uSq / 1024 * (\n                    256 + uSq * (\n                        -128 + uSq * (\n                            74-47 * uSq\n                        )\n                    )\n                )\n            );\n\n            var deltaSigma = (\n                B * sinSigma * (\n                    cos2SigmaM + B / 4 * (\n                        cosSigma * (\n                            -1 + 2 * cos2SigmaM * cos2SigmaM\n                        ) -B / 6 * cos2SigmaM * (\n                            -3 + 4 * sinSigma * sinSigma\n                        ) * (\n                            -3 + 4 * cos2SigmaM * cos2SigmaM\n                        )\n                    )\n                )\n            );\n\n            var distance = b * A * (sigma - deltaSigma);\n\n            distance = distance.toFixed(precision); // round to 1mm precision\n\n            //if (start.hasOwnProperty(elevation) && end.hasOwnProperty(elevation)) {\n            if (typeof this.elevation(start) !== 'undefined' && typeof this.elevation(end) !== 'undefined') {\n                var climb = Math.abs(this.elevation(start) - this.elevation(end));\n                distance = Math.sqrt(distance * distance + climb * climb);\n            }\n\n            return this.distance = Math.round(distance * Math.pow(10, precision) / accuracy) * accuracy / Math.pow(10, precision);\n\n            /*\n            // note: to return initial/final bearings in addition to distance, use something like:\n            var fwdAz = Math.atan2(cosU2*sinLambda,  cosU1*sinU2-sinU1*cosU2*cosLambda);\n            var revAz = Math.atan2(cosU1*sinLambda, -sinU1*cosU2+cosU1*sinU2*cosLambda);\n\n            return { distance: s, initialBearing: fwdAz.toDeg(), finalBearing: revAz.toDeg() };\n            */\n\n        },\n\n\n        /**\n        * Calculates the distance between two spots.\n        * This method is more simple but also far more inaccurate\n        *\n        * @param    object    Start position {latitude: 123, longitude: 123}\n        * @param    object    End position {latitude: 123, longitude: 123}\n        * @param    integer   Accuracy (in meters)\n        * @return   integer   Distance (in meters)\n        */\n        getDistanceSimple: function(start, end, accuracy) {\n\n            accuracy = Math.floor(accuracy) || 1;\n\n            var distance =\n                Math.round(\n                    Math.acos(\n                        Math.sin(\n                            this.latitude(end).toRad()\n                        ) *\n                        Math.sin(\n                            this.latitude(start).toRad()\n                        ) +\n                        Math.cos(\n                            this.latitude(end).toRad()\n                        ) *\n                        Math.cos(\n                            this.latitude(start).toRad()\n                        ) *\n                        Math.cos(\n                            this.longitude(start).toRad() - this.longitude(end).toRad()\n                        )\n                    ) * this.radius\n                );\n\n            return geolib.distance = Math.floor(Math.round(distance/accuracy)*accuracy);\n\n        },\n\n\n    /**\n        * Calculates the center of a collection of geo coordinates\n        *\n        * @param        array       Collection of coords [{latitude: 51.510, longitude: 7.1321}, {latitude: 49.1238, longitude: \"8° 30' W\"}, ...]\n        * @return       object      {latitude: centerLat, longitude: centerLng}\n        */\n        getCenter: function(coords) {\n\n            var coordsArray = coords;\n            if(typeof coords === 'object' && !(coords instanceof Array)) {\n\n                coordsArray = [];\n\n                for(var key in coords) {\n                    coordsArray.push(\n                        this.coords(coords[key])\n                    );\n                }\n\n            }\n\n            if(!coordsArray.length) {\n                return false;\n            }\n\n            var X = 0.0;\n            var Y = 0.0;\n            var Z = 0.0;\n            var lat, lon, hyp;\n\n            coordsArray.forEach(function(coord) {\n\n                lat = this.latitude(coord).toRad();\n                lon = this.longitude(coord).toRad();\n\n                X += Math.cos(lat) * Math.cos(lon);\n                Y += Math.cos(lat) * Math.sin(lon);\n                Z += Math.sin(lat);\n\n            }, this);\n\n            var nb_coords = coordsArray.length;\n            X = X / nb_coords;\n            Y = Y / nb_coords;\n            Z = Z / nb_coords;\n\n            lon = Math.atan2(Y, X);\n            hyp = Math.sqrt(X * X + Y * Y);\n            lat = Math.atan2(Z, hyp);\n\n            return {\n                latitude: (lat * Geolib.TO_DEG).toFixed(6),\n                longitude: (lon * Geolib.TO_DEG).toFixed(6)\n            };\n\n        },\n\n\n        /**\n        * Gets the max and min, latitude, longitude, and elevation (if provided).\n        * @param        array       array with coords e.g. [{latitude: 51.5143, longitude: 7.4138}, {latitude: 123, longitude: 123}, ...]\n        * @return   object      {maxLat: maxLat,\n        *                     minLat: minLat\n        *                     maxLng: maxLng,\n        *                     minLng: minLng,\n        *                     maxElev: maxElev,\n        *                     minElev: minElev}\n        */\n        getBounds: function(coords) {\n\n            if (!coords.length) {\n                return false;\n            }\n\n            var useElevation = this.elevation(coords[0]);\n\n            var stats = {\n                maxLat: -Infinity,\n                minLat: Infinity,\n                maxLng: -Infinity,\n                minLng: Infinity\n            };\n\n            if (typeof useElevation != 'undefined') {\n                stats.maxElev = 0;\n                stats.minElev = Infinity;\n            }\n\n            for (var i = 0, l = coords.length; i < l; ++i) {\n\n                stats.maxLat = Math.max(this.latitude(coords[i]), stats.maxLat);\n                stats.minLat = Math.min(this.latitude(coords[i]), stats.minLat);\n                stats.maxLng = Math.max(this.longitude(coords[i]), stats.maxLng);\n                stats.minLng = Math.min(this.longitude(coords[i]), stats.minLng);\n\n                if (useElevation) {\n                    stats.maxElev = Math.max(this.elevation(coords[i]), stats.maxElev);\n                    stats.minElev = Math.min(this.elevation(coords[i]), stats.minElev);\n                }\n\n            }\n\n            return stats;\n\n        },\n\n        /**\n        * Calculates the center of the bounds of geo coordinates.\n        *\n        * On polygons like political borders (eg. states)\n        * this may gives a closer result to human expectation, than `getCenter`,\n        * because that function can be disturbed by uneven distribution of\n        * point in different sides.\n        * Imagine the US state Oklahoma: `getCenter` on that gives a southern\n        * point, because the southern border contains a lot more nodes,\n        * than the others.\n        *\n        * @param        array       Collection of coords [{latitude: 51.510, longitude: 7.1321}, {latitude: 49.1238, longitude: \"8° 30' W\"}, ...]\n        * @return       object      {latitude: centerLat, longitude: centerLng}\n        */\n        getCenterOfBounds: function(coords) {\n            var b = this.getBounds(coords);\n            var latitude = b.minLat + ((b.maxLat - b.minLat) / 2);\n            var longitude = b.minLng + ((b.maxLng - b.minLng) / 2);\n            return {\n                latitude: parseFloat(latitude.toFixed(6)),\n                longitude: parseFloat(longitude.toFixed(6))\n            };\n        },\n\n\n        /**\n        * Computes the bounding coordinates of all points on the surface\n        * of the earth less than or equal to the specified great circle\n        * distance.\n        *\n        * @param object Point position {latitude: 123, longitude: 123}\n        * @param number Distance (in meters).\n        * @return array Collection of two points defining the SW and NE corners.\n        */\n        getBoundsOfDistance: function(point, distance) {\n\n            var latitude = this.latitude(point);\n            var longitude = this.longitude(point);\n\n            var radLat = latitude.toRad();\n            var radLon = longitude.toRad();\n\n            var radDist = distance / this.radius;\n            var minLat = radLat - radDist;\n            var maxLat = radLat + radDist;\n\n            var MAX_LAT_RAD = this.maxLat.toRad();\n            var MIN_LAT_RAD = this.minLat.toRad();\n            var MAX_LON_RAD = this.maxLon.toRad();\n            var MIN_LON_RAD = this.minLon.toRad();\n\n            var minLon;\n            var maxLon;\n\n            if (minLat > MIN_LAT_RAD && maxLat < MAX_LAT_RAD) {\n\n                var deltaLon = Math.asin(Math.sin(radDist) / Math.cos(radLat));\n                minLon = radLon - deltaLon;\n\n                if (minLon < MIN_LON_RAD) {\n                    minLon += Geolib.PI_X2;\n                }\n\n                maxLon = radLon + deltaLon;\n\n                if (maxLon > MAX_LON_RAD) {\n                    maxLon -= Geolib.PI_X2;\n                }\n\n            } else {\n                // A pole is within the distance.\n                minLat = Math.max(minLat, MIN_LAT_RAD);\n                maxLat = Math.min(maxLat, MAX_LAT_RAD);\n                minLon = MIN_LON_RAD;\n                maxLon = MAX_LON_RAD;\n            }\n\n            return [\n                // Southwest\n                {\n                    latitude: minLat.toDeg(),\n                    longitude: minLon.toDeg()\n                },\n                // Northeast\n                {\n                    latitude: maxLat.toDeg(),\n                    longitude: maxLon.toDeg()\n                }\n            ];\n\n        },\n\n\n        /**\n        * Checks whether a point is inside of a polygon or not.\n        * Note that the polygon coords must be in correct order!\n        *\n        * @param        object      coordinate to check e.g. {latitude: 51.5023, longitude: 7.3815}\n        * @param        array       array with coords e.g. [{latitude: 51.5143, longitude: 7.4138}, {latitude: 123, longitude: 123}, ...]\n        * @return       bool        true if the coordinate is inside the given polygon\n        */\n        isPointInside: function(latlng, coords) {\n\n            for(var c = false, i = -1, l = coords.length, j = l - 1; ++i < l; j = i) {\n\n                if(\n                    (\n                        (this.longitude(coords[i]) <= this.longitude(latlng) && this.longitude(latlng) < this.longitude(coords[j])) ||\n                        (this.longitude(coords[j]) <= this.longitude(latlng) && this.longitude(latlng) < this.longitude(coords[i]))\n                    ) &&\n                    (\n                        this.latitude(latlng) < (this.latitude(coords[j]) - this.latitude(coords[i])) *\n                        (this.longitude(latlng) - this.longitude(coords[i])) /\n                        (this.longitude(coords[j]) - this.longitude(coords[i])) +\n                        this.latitude(coords[i])\n                    )\n                ) {\n                    c = !c;\n                }\n\n            }\n\n            return c;\n\n        },\n\n\n       /**\n        * Pre calculate the polygon coords, to speed up the point inside check.\n        * Use this function before calling isPointInsideWithPreparedPolygon()\n        * @see          Algorythm from http://alienryderflex.com/polygon/\n        * @param        array       array with coords e.g. [{latitude: 51.5143, longitude: 7.4138}, {latitude: 123, longitude: 123}, ...]\n        */\n        preparePolygonForIsPointInsideOptimized: function(coords) {\n\n            for(var i = 0, j = coords.length-1; i < coords.length; i++) {\n\n            if(this.longitude(coords[j]) === this.longitude(coords[i])) {\n\n                    coords[i].constant = this.latitude(coords[i]);\n                    coords[i].multiple = 0;\n\n                } else {\n\n                    coords[i].constant = this.latitude(coords[i]) - (\n                        this.longitude(coords[i]) * this.latitude(coords[j])\n                    ) / (\n                        this.longitude(coords[j]) - this.longitude(coords[i])\n                    ) + (\n                        this.longitude(coords[i])*this.latitude(coords[i])\n                    ) / (\n                        this.longitude(coords[j])-this.longitude(coords[i])\n                    );\n\n                    coords[i].multiple = (\n                        this.latitude(coords[j])-this.latitude(coords[i])\n                    ) / (\n                        this.longitude(coords[j])-this.longitude(coords[i])\n                    );\n\n                }\n\n                j=i;\n\n            }\n\n        },\n\n      /**\n       * Checks whether a point is inside of a polygon or not.\n       * \"This is useful if you have many points that need to be tested against the same (static) polygon.\"\n       * Please call the function preparePolygonForIsPointInsideOptimized() with the same coords object before using this function.\n       * Note that the polygon coords must be in correct order!\n       *\n       * @see          Algorythm from http://alienryderflex.com/polygon/\n       *\n       * @param     object      coordinate to check e.g. {latitude: 51.5023, longitude: 7.3815}\n       * @param     array       array with coords e.g. [{latitude: 51.5143, longitude: 7.4138}, {latitude: 123, longitude: 123}, ...]\n       * @return        bool        true if the coordinate is inside the given polygon\n       */\n        isPointInsideWithPreparedPolygon: function(point, coords) {\n\n            var flgPointInside = false,\n            y = this.longitude(point),\n            x = this.latitude(point);\n\n            for(var i = 0, j = coords.length-1; i < coords.length; i++) {\n\n                if ((this.longitude(coords[i]) < y && this.longitude(coords[j]) >=y ||\n                    this.longitude(coords[j]) < y && this.longitude(coords[i]) >= y)) {\n\n                    flgPointInside^=(y*coords[i].multiple+coords[i].constant < x);\n\n                }\n\n                j=i;\n\n            }\n\n            return flgPointInside;\n\n        },\n\n\n        /**\n        * Shortcut for geolib.isPointInside()\n        */\n        isInside: function() {\n            return this.isPointInside.apply(this, arguments);\n        },\n\n\n        /**\n        * Checks whether a point is inside of a circle or not.\n        *\n        * @param        object      coordinate to check (e.g. {latitude: 51.5023, longitude: 7.3815})\n        * @param        object      coordinate of the circle's center (e.g. {latitude: 51.4812, longitude: 7.4025})\n        * @param        integer     maximum radius in meters\n        * @return       bool        true if the coordinate is within the given radius\n        */\n        isPointInCircle: function(latlng, center, radius) {\n            return this.getDistance(latlng, center) < radius;\n        },\n\n\n        /**\n        * Shortcut for geolib.isPointInCircle()\n        */\n        withinRadius: function() {\n            return this.isPointInCircle.apply(this, arguments);\n        },\n\n\n        /**\n        * Gets rhumb line bearing of two points. Find out about the difference between rhumb line and\n        * great circle bearing on Wikipedia. It's quite complicated. Rhumb line should be fine in most cases:\n        *\n        * http://en.wikipedia.org/wiki/Rhumb_line#General_and_mathematical_description\n        *\n        * Function heavily based on Doug Vanderweide's great PHP version (licensed under GPL 3.0)\n        * http://www.dougv.com/2009/07/13/calculating-the-bearing-and-compass-rose-direction-between-two-latitude-longitude-coordinates-in-php/\n        *\n        * @param        object      origin coordinate (e.g. {latitude: 51.5023, longitude: 7.3815})\n        * @param        object      destination coordinate\n        * @return       integer     calculated bearing\n        */\n        getRhumbLineBearing: function(originLL, destLL) {\n\n            // difference of longitude coords\n            var diffLon = this.longitude(destLL).toRad() - this.longitude(originLL).toRad();\n\n            // difference latitude coords phi\n            var diffPhi = Math.log(\n                Math.tan(\n                    this.latitude(destLL).toRad() / 2 + Geolib.PI_DIV4\n                ) /\n                Math.tan(\n                    this.latitude(originLL).toRad() / 2 + Geolib.PI_DIV4\n                )\n            );\n\n            // recalculate diffLon if it is greater than pi\n            if(Math.abs(diffLon) > Math.PI) {\n                if(diffLon > 0) {\n                    diffLon = (Geolib.PI_X2 - diffLon) * -1;\n                }\n                else {\n                    diffLon = Geolib.PI_X2 + diffLon;\n                }\n            }\n\n            //return the angle, normalized\n            return (Math.atan2(diffLon, diffPhi).toDeg() + 360) % 360;\n\n        },\n\n\n        /**\n        * Gets great circle bearing of two points. See description of getRhumbLineBearing for more information\n        *\n        * @param        object      origin coordinate (e.g. {latitude: 51.5023, longitude: 7.3815})\n        * @param        object      destination coordinate\n        * @return       integer     calculated bearing\n        */\n        getBearing: function(originLL, destLL) {\n\n            destLL['latitude'] = this.latitude(destLL);\n            destLL['longitude'] = this.longitude(destLL);\n            originLL['latitude'] = this.latitude(originLL);\n            originLL['longitude'] = this.longitude(originLL);\n\n            var bearing = (\n                (\n                    Math.atan2(\n                        Math.sin(\n                            destLL['longitude'].toRad() -\n                            originLL['longitude'].toRad()\n                        ) *\n                        Math.cos(\n                            destLL['latitude'].toRad()\n                        ),\n                        Math.cos(\n                            originLL['latitude'].toRad()\n                        ) *\n                        Math.sin(\n                            destLL['latitude'].toRad()\n                        ) -\n                        Math.sin(\n                            originLL['latitude'].toRad()\n                        ) *\n                        Math.cos(\n                            destLL['latitude'].toRad()\n                        ) *\n                        Math.cos(\n                            destLL['longitude'].toRad() - originLL['longitude'].toRad()\n                        )\n                    )\n                ).toDeg() + 360\n            ) % 360;\n\n            return bearing;\n\n        },\n\n\n        /**\n        * Gets the compass direction from an origin coordinate to a destination coordinate.\n        *\n        * @param        object      origin coordinate (e.g. {latitude: 51.5023, longitude: 7.3815})\n        * @param        object      destination coordinate\n        * @param        string      Bearing mode. Can be either circle or rhumbline\n        * @return       object      Returns an object with a rough (NESW) and an exact direction (NNE, NE, ENE, E, ESE, etc).\n        */\n        getCompassDirection: function(originLL, destLL, bearingMode) {\n\n            var direction;\n            var bearing;\n\n            if(bearingMode == 'circle') {\n                // use great circle bearing\n                bearing = this.getBearing(originLL, destLL);\n            } else {\n                // default is rhumb line bearing\n                bearing = this.getRhumbLineBearing(originLL, destLL);\n            }\n\n            switch(Math.round(bearing/22.5)) {\n                case 1:\n                    direction = {exact: \"NNE\", rough: \"N\"};\n                    break;\n                case 2:\n                    direction = {exact: \"NE\", rough: \"N\"};\n                    break;\n                case 3:\n                    direction = {exact: \"ENE\", rough: \"E\"};\n                    break;\n                case 4:\n                    direction = {exact: \"E\", rough: \"E\"};\n                    break;\n                case 5:\n                    direction = {exact: \"ESE\", rough: \"E\"};\n                    break;\n                case 6:\n                    direction = {exact: \"SE\", rough: \"E\"};\n                    break;\n                case 7:\n                    direction = {exact: \"SSE\", rough: \"S\"};\n                    break;\n                case 8:\n                    direction = {exact: \"S\", rough: \"S\"};\n                    break;\n                case 9:\n                    direction = {exact: \"SSW\", rough: \"S\"};\n                    break;\n                case 10:\n                    direction = {exact: \"SW\", rough: \"S\"};\n                    break;\n                case 11:\n                    direction = {exact: \"WSW\", rough: \"W\"};\n                    break;\n                case 12:\n                    direction = {exact: \"W\", rough: \"W\"};\n                    break;\n                case 13:\n                    direction = {exact: \"WNW\", rough: \"W\"};\n                    break;\n                case 14:\n                    direction = {exact: \"NW\", rough: \"W\"};\n                    break;\n                case 15:\n                    direction = {exact: \"NNW\", rough: \"N\"};\n                    break;\n                default:\n                    direction = {exact: \"N\", rough: \"N\"};\n            }\n\n            direction['bearing'] = bearing;\n            return direction;\n\n        },\n\n\n        /**\n        * Shortcut for getCompassDirection\n        */\n        getDirection: function(originLL, destLL, bearingMode) {\n            return this.getCompassDirection.apply(this, arguments);\n        },\n\n\n        /**\n        * Sorts an array of coords by distance from a reference coordinate\n        *\n        * @param        object      reference coordinate e.g. {latitude: 51.5023, longitude: 7.3815}\n        * @param        mixed       array or object with coords [{latitude: 51.5143, longitude: 7.4138}, {latitude: 123, longitude: 123}, ...]\n        * @return       array       ordered array\n        */\n        orderByDistance: function(latlng, coords) {\n\n            var coordsArray = Object.keys(coords).map(function(idx) {\n                var distance = this.getDistance(latlng, coords[idx]);\n                var augmentedCoord = Object.create(coords[idx]);\n                augmentedCoord.distance = distance;\n                augmentedCoord.key = idx;\n                return augmentedCoord;\n            }, this);\n\n            return coordsArray.sort(function(a, b) {\n                return a.distance - b.distance;\n            });\n\n        },\n\n        /**\n        * Check if a point lies in line created by two other points\n        *\n        * @param    object    Point to check: {latitude: 123, longitude: 123}\n        * @param    object    Start of line {latitude: 123, longitude: 123}\n        * @param    object    End of line {latitude: 123, longitude: 123}\n        * @return   boolean\n        */\n        isPointInLine: function(point, start, end) {\n\n            return (this.getDistance(start, point, 1, 3)+this.getDistance(point, end, 1, 3)).toFixed(3)==this.getDistance(start, end, 1, 3);\n        },\n\n                /**\n        * Check if a point lies within a given distance from a line created by two other points\n        *\n        * @param    object    Point to check: {latitude: 123, longitude: 123}\n        * @param    object    Start of line {latitude: 123, longitude: 123}\n        * @param    object    End of line {latitude: 123, longitude: 123}\n        * @pararm   float     maximum distance from line\n        * @return   boolean\n        */\n        isPointNearLine: function(point, start, end, distance) {\n            return this.getDistanceFromLine(point, start, end) < distance;\n        },\n\n                     /**\n        * return the minimum distance from a point to a line\n        *\n        * @param    object    Point away from line\n        * @param    object    Start of line {latitude: 123, longitude: 123}\n        * @param    object    End of line {latitude: 123, longitude: 123}\n        * @return   float     distance from point to line\n        */\n        getDistanceFromLine: function(point, start, end) {\n            var d1 = this.getDistance(start, point, 1, 3);\n            var d2 = this.getDistance(point, end, 1, 3);\n            var d3 = this.getDistance(start, end, 1, 3);\n            var distance = 0;\n\n            // alpha is the angle between the line from start to point, and from start to end //\n            var alpha = Math.acos((d1*d1 + d3*d3 - d2*d2)/(2*d1*d3));\n            // beta is the angle between the line from end to point and from end to start //\n            var beta = Math.acos((d2*d2 + d3*d3 - d1*d1)/(2*d2*d3));\n\n            // if the angle is greater than 90 degrees, then the minimum distance is the\n            // line from the start to the point //\n            if(alpha>Math.PI/2) {\n                distance = d1;\n            }\n            // same for the beta //\n            else if(beta > Math.PI/2) {\n                distance = d2;\n            }\n            // otherwise the minimum distance is achieved through a line perpendular to the start-end line,\n            // which goes from the start-end line to the point //\n            else {\n                distance = Math.sin(alpha) * d1;\n            }\n\n            return distance;\n        },\n\n        /**\n        * Finds the nearest coordinate to a reference coordinate\n        *\n        * @param        object      reference coordinate e.g. {latitude: 51.5023, longitude: 7.3815}\n        * @param        mixed       array or object with coords [{latitude: 51.5143, longitude: 7.4138}, {latitude: 123, longitude: 123}, ...]\n        * @return       array       ordered array\n        */\n        findNearest: function(latlng, coords, offset, limit) {\n\n            offset = offset || 0;\n            limit = limit || 1;\n            var ordered = this.orderByDistance(latlng, coords);\n\n            if(limit === 1) {\n                return ordered[offset];\n            } else {\n                return ordered.splice(offset, limit);\n            }\n\n        },\n\n\n        /**\n        * Calculates the length of a given path\n        *\n        * @param        mixed       array or object with coords [{latitude: 51.5143, longitude: 7.4138}, {latitude: 123, longitude: 123}, ...]\n        * @return       integer     length of the path (in meters)\n        */\n        getPathLength: function(coords) {\n\n            var dist = 0;\n            var last;\n\n            for (var i = 0, l = coords.length; i < l; ++i) {\n                if(last) {\n                    //console.log(coords[i], last, this.getDistance(coords[i], last));\n                    dist += this.getDistance(this.coords(coords[i]), last);\n                }\n                last = this.coords(coords[i]);\n            }\n\n            return dist;\n\n        },\n\n\n        /**\n        * Calculates the speed between to points within a given time span.\n        *\n        * @param        object      coords with javascript timestamp {latitude: 51.5143, longitude: 7.4138, time: 1360231200880}\n        * @param        object      coords with javascript timestamp {latitude: 51.5502, longitude: 7.4323, time: 1360245600460}\n        * @param        object      options (currently \"unit\" is the only option. Default: km(h));\n        * @return       float       speed in unit per hour\n        */\n        getSpeed: function(start, end, options) {\n\n            var unit = options && options.unit || 'km';\n\n            if(unit == 'mph') {\n                unit = 'mi';\n            } else if(unit == 'kmh') {\n                unit = 'km';\n            }\n\n            var distance = geolib.getDistance(start, end);\n            var time = ((end.time*1)/1000) - ((start.time*1)/1000);\n            var mPerHr = (distance/time)*3600;\n            var speed = Math.round(mPerHr * this.measures[unit] * 10000)/10000;\n            return speed;\n\n        },\n\n\n        /**\n         * Computes the destination point given an initial point, a distance\n         * and a bearing\n         *\n         * see http://www.movable-type.co.uk/scripts/latlong.html for the original code\n         *\n         * @param        object     start coordinate (e.g. {latitude: 51.5023, longitude: 7.3815})\n         * @param        float      longitude of the inital point in degree\n         * @param        float      distance to go from the inital point in meter\n         * @param        float      bearing in degree of the direction to go, e.g. 0 = north, 180 = south\n         * @param        float      optional (in meter), defaults to mean radius of the earth\n         * @return       object     {latitude: destLat (in degree), longitude: destLng (in degree)}\n         */\n        computeDestinationPoint: function(start, distance, bearing, radius) {\n\n            var lat = this.latitude(start);\n            var lng = this.longitude(start);\n\n            radius = (typeof radius === 'undefined') ? this.radius : Number(radius);\n\n            var δ = Number(distance) / radius; // angular distance in radians\n            var θ = Number(bearing).toRad();\n\n            var φ1 = Number(lat).toRad();\n            var λ1 = Number(lng).toRad();\n\n            var φ2 = Math.asin( Math.sin(φ1)*Math.cos(δ) +\n                Math.cos(φ1)*Math.sin(δ)*Math.cos(θ) );\n            var λ2 = λ1 + Math.atan2(Math.sin(θ)*Math.sin(δ)*Math.cos(φ1),\n                    Math.cos(δ)-Math.sin(φ1)*Math.sin(φ2));\n            λ2 = (λ2+3*Math.PI) % (2*Math.PI) - Math.PI; // normalise to -180..+180°\n\n            return {\n                latitude: φ2.toDeg(),\n                longitude: λ2.toDeg()\n            };\n\n        },\n\n\n        /**\n        * Converts a distance from meters to km, mm, cm, mi, ft, in or yd\n        *\n        * @param        string      Format to be converted in\n        * @param        float       Distance in meters\n        * @param        float       Decimal places for rounding (default: 4)\n        * @return       float       Converted distance\n        */\n        convertUnit: function(unit, distance, round) {\n\n            if(distance === 0) {\n\n                return 0;\n\n            } else if(typeof distance === 'undefined') {\n\n                if(this.distance === null) {\n                    throw new Error('No distance was given');\n                } else if(this.distance === 0) {\n                    return 0;\n                } else {\n                    distance = this.distance;\n                }\n\n            }\n\n            unit = unit || 'm';\n            round = (null == round ? 4 : round);\n\n            if(typeof this.measures[unit] !== 'undefined') {\n                return this.round(distance * this.measures[unit], round);\n            } else {\n                throw new Error('Unknown unit for conversion.');\n            }\n\n        },\n\n\n        /**\n        * Checks if a value is in decimal format or, if neccessary, converts to decimal\n        *\n        * @param        mixed       Value(s) to be checked/converted (array of latlng objects, latlng object, sexagesimal string, float)\n        * @return       float       Input data in decimal format\n        */\n        useDecimal: function(value) {\n\n            if(Object.prototype.toString.call(value) === '[object Array]') {\n\n                var geolib = this;\n\n                value = value.map(function(val) {\n\n                    //if(!isNaN(parseFloat(val))) {\n                    if(geolib.isDecimal(val)) {\n\n                        return geolib.useDecimal(val);\n\n                    } else if(typeof val == 'object') {\n\n                        if(geolib.validate(val)) {\n\n                            return geolib.coords(val);\n\n                        } else {\n\n                            for(var prop in val) {\n                                val[prop] = geolib.useDecimal(val[prop]);\n                            }\n\n                            return val;\n\n                        }\n\n                    } else if(geolib.isSexagesimal(val)) {\n\n                        return geolib.sexagesimal2decimal(val);\n\n                    } else {\n\n                        return val;\n\n                    }\n\n                });\n\n                return value;\n\n            } else if(typeof value === 'object' && this.validate(value)) {\n\n                return this.coords(value);\n\n            } else if(typeof value === 'object') {\n\n                for(var prop in value) {\n                    value[prop] = this.useDecimal(value[prop]);\n                }\n\n                return value;\n\n            }\n\n\n            if (this.isDecimal(value)) {\n\n                return parseFloat(value);\n\n            } else if(this.isSexagesimal(value) === true) {\n\n                return parseFloat(this.sexagesimal2decimal(value));\n\n            }\n\n            throw new Error('Unknown format.');\n\n        },\n\n        /**\n        * Converts a decimal coordinate value to sexagesimal format\n        *\n        * @param        float       decimal\n        * @return       string      Sexagesimal value (XX° YY' ZZ\")\n        */\n        decimal2sexagesimal: function(dec) {\n\n            if (dec in this.sexagesimal) {\n                return this.sexagesimal[dec];\n            }\n\n            var tmp = dec.toString().split('.');\n\n            var deg = Math.abs(tmp[0]);\n            var min = ('0.' + (tmp[1] || 0))*60;\n            var sec = min.toString().split('.');\n\n            min = Math.floor(min);\n            sec = (('0.' + (sec[1] || 0)) * 60).toFixed(2);\n\n            this.sexagesimal[dec] = (deg + '° ' + min + \"' \" + sec + '\"');\n\n            return this.sexagesimal[dec];\n\n        },\n\n\n        /**\n        * Converts a sexagesimal coordinate to decimal format\n        *\n        * @param        float       Sexagesimal coordinate\n        * @return       string      Decimal value (XX.XXXXXXXX)\n        */\n        sexagesimal2decimal: function(sexagesimal) {\n\n            if (sexagesimal in this.decimal) {\n                return this.decimal[sexagesimal];\n            }\n\n            var regEx = new RegExp(this.sexagesimalPattern);\n            var data = regEx.exec(sexagesimal);\n            var min = 0, sec = 0;\n\n            if(data) {\n                min = parseFloat(data[2]/60);\n                sec = parseFloat(data[4]/3600) || 0;\n            }\n\n            var dec = ((parseFloat(data[1]) + min + sec)).toFixed(8);\n            //var   dec = ((parseFloat(data[1]) + min + sec));\n\n                // South and West are negative decimals\n                dec = (data[7] == 'S' || data[7] == 'W') ? parseFloat(-dec) : parseFloat(dec);\n                //dec = (data[7] == 'S' || data[7] == 'W') ? -dec : dec;\n\n            this.decimal[sexagesimal] = dec;\n\n            return dec;\n\n        },\n\n\n        /**\n        * Checks if a value is in decimal format\n        *\n        * @param        string      Value to be checked\n        * @return       bool        True if in sexagesimal format\n        */\n        isDecimal: function(value) {\n\n            value = value.toString().replace(/\\s*/, '');\n\n            // looks silly but works as expected\n            // checks if value is in decimal format\n            return (!isNaN(parseFloat(value)) && parseFloat(value) == value);\n\n        },\n\n\n        /**\n        * Checks if a value is in sexagesimal format\n        *\n        * @param        string      Value to be checked\n        * @return       bool        True if in sexagesimal format\n        */\n        isSexagesimal: function(value) {\n\n            value = value.toString().replace(/\\s*/, '');\n\n            return this.sexagesimalPattern.test(value);\n\n        },\n\n        round: function(value, n) {\n            var decPlace = Math.pow(10, n);\n            return Math.round(value * decPlace)/decPlace;\n        }\n\n    });\n\n    // Node module\n    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n\n        module.exports = geolib;\n\n        // react native\n        if (typeof global === 'object') {\n          global.geolib = geolib;\n        }\n\n    // AMD module\n    } else if (typeof define === \"function\" && define.amd) {\n\n        define(\"geolib\", [], function () {\n            return geolib;\n        });\n\n    // we're in a browser\n    } else {\n\n        global.geolib = geolib;\n\n    }\n\n}(this));\n"]},"metadata":{},"sourceType":"script"}